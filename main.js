/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var f=Object.defineProperty;var x=Object.getOwnPropertyDescriptor;var k=Object.getOwnPropertyNames;var w=Object.prototype.hasOwnProperty;var v=(u,l)=>{for(var t in l)f(u,t,{get:l[t],enumerable:!0})},b=(u,l,t,e)=>{if(l&&typeof l=="object"||typeof l=="function")for(let s of k(l))!w.call(u,s)&&s!==t&&f(u,s,{get:()=>l[s],enumerable:!(e=x(l,s))||e.enumerable});return u};var y=u=>b(f({},"__esModule",{value:!0}),u);var I={};v(I,{default:()=>p});module.exports=y(I);var i=require("obsidian"),N={taskFormats:["[ACTION]","[action]"],indexNotePath:"Taskmaster.md",autoRefresh:!0,includeHeaders:!0,refreshInterval:3e5},p=class extends i.Plugin{constructor(){super(...arguments);this.refreshDebounceTimer=null}async onload(){await this.loadSettings(),this.addSettingTab(new m(this.app,this)),this.addCommand({id:"refresh-taskmaster",name:"Refresh Taskmaster",callback:()=>this.refreshIndex()}),this.addRibbonIcon("file-check-2","Refresh Taskmaster",()=>{this.refreshIndex()}),this.registerEvent(this.app.vault.on("modify",async t=>{t.path===this.settings.indexNotePath?await this.handleIndexModification(t):this.settings.autoRefresh&&this.debouncedRefresh()})),this.app.workspace.onLayoutReady(()=>this.refreshIndex())}async loadSettings(){this.settings=Object.assign({},N,await this.loadData())}async saveSettings(){await this.saveData(this.settings)}debouncedRefresh(){this.refreshDebounceTimer&&clearTimeout(this.refreshDebounceTimer),this.refreshDebounceTimer=setTimeout(()=>this.refreshIndex(),this.settings.refreshInterval)}async handleIndexModification(t){if(t instanceof i.TFile){let s=(await this.app.vault.read(t)).split(`
`),a=(await this.getOldFileContent(t)).split(`
`);for(let n=0;n<s.length;n++){let h=s[n],c=a[n];if(this.isTaskLine(h)&&this.isTaskLine(c)&&h!==c){let o=this.parseSourceLink(h);o&&await this.updateSourceTask(o,h)}}}else console.error("Invalid file type:",t)}async getOldFileContent(t){let e=this.app.workspace.getActiveViewOfType(i.MarkdownView);return e&&e.file===t?e.data:await this.app.vault.read(t)}isTaskLine(t){let e=t.match(/`[^`]*`/);return t.trim().startsWith("```")||e?!1:t.trim().startsWith("- [ ]")||t.trim().startsWith("* [ ]")||t.trim().startsWith("- [x]")||t.trim().startsWith("* [x]")||t.trim().startsWith("- [X]")||t.trim().startsWith("* [X]")}parseSourceLink(t){let e=t.match(/\[\[(.*?)#(\d+)\]\]/);return e?{file:e[1],lineNumber:parseInt(e[2],10)}:null}async updateSourceTask(t,e){let s=this.app.vault.getAbstractFileByPath(t.file);if(!(s instanceof i.TFile))return;let a=(await this.app.vault.read(s)).split(`
`),n=t.lineNumber-1;if(n>=0&&n<a.length){let h=a[n],c=this.isTaskComplete(e);a[n]=this.updateTaskStatus(h,c),await this.app.vault.modify(s,a.join(`
`)),new i.Notice("Source task updated")}}getTaskText(t){return t.replace(/^[*-]\s*\[[x ]\]\s*/i,"").replace(/\[\[.*?\]\]/g,"").trim()}isTaskComplete(t){return t.match(/\[(x|X)\]/)!==null}updateTaskStatus(t,e){return t.replace(/\[[x ]\]/i,e?"[x]":"[ ]")}async refreshIndex(){try{let t=await this.scanVaultForTasks();await this.generateIndexNote(t),new i.Notice("Task index updated")}catch(t){new i.Notice("Error updating task index: "+t.message),console.error("Task Index Error:",t)}}async scanVaultForTasks(){let t=[],e=this.app.vault.getMarkdownFiles();for(let s of e){if(s.path===this.settings.indexNotePath)continue;let a=(await this.app.vault.read(s)).split(`
`),n=[],h=!1;for(let c=0;c<a.length;c++){let o=a[c];if(o.trim().startsWith("```")){h=!h;continue}if(!h){if(o.startsWith("#")&&o.includes(" ")&&!o.startsWith("#tag")&&!o.match(/^#\w+$/)){let d=o.match(/^#+\s/);if(d){let g=d[0].trim().length;n[g-1]=o.replace(/^#+\s+/,""),n.length=g}}for(let d of this.settings.taskFormats){let g=o.trimStart().startsWith(d),T=!o.includes("`")&&!h;g&&T&&!o.match(/\[(x|X)\]/)&&t.push({text:o.trim(),sourcePath:s.path,lineNumber:c+1,headers:[...n]})}}}}return t}async generateIndexNote(t){let e=this.formatIndexContent(t),s=this.app.vault.getAbstractFileByPath(this.settings.indexNotePath);s instanceof i.TFile?await this.app.vault.modify(s,e):await this.app.vault.create(this.settings.indexNotePath,e)}formatIndexContent(t){let e=["# Task Index","","Generated: "+new Date().toLocaleString(),""],s=t.reduce((r,a)=>{let n=a.headers.join(" > ")||"No Context";return r[a.sourcePath]||(r[a.sourcePath]={}),r[a.sourcePath][n]||(r[a.sourcePath][n]=[]),r[a.sourcePath][n].push(a),r},{});for(let[r,a]of Object.entries(s)){e.push(`### [[${r}]]`);for(let[n,h]of Object.entries(a)){this.settings.includeHeaders&&n!=="No Context"&&e.push(`**Context: ${n}**`);for(let c of h){let o=`[[${c.sourcePath}#${c.lineNumber}]]`;e.push(`${c.text} (${o})`)}e.push("")}}return e.join(`
`)}},m=class extends i.PluginSettingTab{constructor(t,e){super(t,e);this.plugin=e}display(){let{containerEl:t}=this;t.empty(),t.createEl("h2",{text:"Taskmaster Settings"}),new i.Setting(t).setName("Task Formats").setDesc("Enter task formats to track, one per line").addTextArea(e=>e.setPlaceholder(`- [ ]
* [ ]`).setValue(this.plugin.settings.taskFormats.join(`
`)).onChange(async s=>{this.plugin.settings.taskFormats=s.split(`
`).map(r=>r.trim()).filter(r=>r.length>0),await this.plugin.saveSettings()})),new i.Setting(t).setName("Index Note Path").setDesc("Path where the task index will be created").addText(e=>e.setPlaceholder("Taskmaster.md").setValue(this.plugin.settings.indexNotePath).onChange(async s=>{this.plugin.settings.indexNotePath=s,await this.plugin.saveSettings()})),new i.Setting(t).setName("Auto Refresh").setDesc("Automatically refresh index when files change").addToggle(e=>e.setValue(this.plugin.settings.autoRefresh).onChange(async s=>{this.plugin.settings.autoRefresh=s,await this.plugin.saveSettings()})),new i.Setting(t).setName("Include Headers").setDesc("Include header hierarchy for context").addToggle(e=>e.setValue(this.plugin.settings.includeHeaders).onChange(async s=>{this.plugin.settings.includeHeaders=s,await this.plugin.saveSettings()})),new i.Setting(t).setName("Refresh Interval").setDesc("Minutes to wait before auto-refreshing (min: 5)").addText(e=>e.setPlaceholder("5").setValue(String(this.plugin.settings.refreshInterval/6e4)).onChange(async s=>{let r=Number(s)*6e4;r>=3e5&&(this.plugin.settings.refreshInterval=r,await this.plugin.saveSettings())}))}};
